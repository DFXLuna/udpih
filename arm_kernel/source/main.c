#include "imports.h"
#include "recovery_loader.h"

#include "../../arm_user/arm_user.bin.h"

static const uint8_t repairData_set_fault_behavior[] = {
    0xE1,0x2F,0xFF,0x1E,0xE9,0x2D,0x40,0x30,0xE5,0x93,0x20,0x00,0xE1,0xA0,0x40,0x00,
    0xE5,0x92,0x30,0x54,0xE1,0xA0,0x50,0x01,0xE3,0x53,0x00,0x01,0x0A,0x00,0x00,0x02,
    0xE1,0x53,0x00,0x00,0xE3,0xE0,0x00,0x00,0x18,0xBD,0x80,0x30,0xE3,0x54,0x00,0x0D,
};

static const uint8_t repairData_set_panic_behavior[] = {
    0x08,0x16,0x6C,0x00,0x00,0x00,0x18,0x0C,0x08,0x14,0x40,0x00,0x00,0x00,0x9D,0x70,
    0x08,0x16,0x84,0x0C,0x00,0x00,0xB4,0x0C,0x00,0x00,0x01,0x01,0x08,0x14,0x40,0x00,
    0x08,0x15,0x00,0x00,0x08,0x17,0x21,0x80,0x08,0x17,0x38,0x00,0x08,0x14,0x30,0xD4,
    0x08,0x14,0x12,0x50,0x08,0x14,0x12,0x94,0xE3,0xA0,0x35,0x36,0xE5,0x93,0x21,0x94,
    0xE3,0xC2,0x2E,0x21,0xE5,0x83,0x21,0x94,0xE5,0x93,0x11,0x94,0xE1,0x2F,0xFF,0x1E,
    0xE5,0x9F,0x30,0x1C,0xE5,0x9F,0xC0,0x1C,0xE5,0x93,0x20,0x00,0xE1,0xA0,0x10,0x00,
    0xE5,0x92,0x30,0x54,0xE5,0x9C,0x00,0x00,
};

static const uint8_t repairData_usb_root_thread[] = {
    0xE5,0x8D,0xE0,0x04,0xE5,0x8D,0xC0,0x08,0xE5,0x8D,0x40,0x0C,0xE5,0x8D,0x60,0x10,
    0xEB,0x00,0xB2,0xFD,0xEA,0xFF,0xFF,0xC9,0x10,0x14,0x03,0xF8,0x10,0x62,0x4D,0xD3,
    0x10,0x14,0x50,0x00,0x10,0x14,0x50,0x20,0x10,0x14,0x00,0x00,0x10,0x14,0x00,0x90,
    0x10,0x14,0x00,0x70,0x10,0x14,0x00,0x98,0x10,0x14,0x00,0x84,0x10,0x14,0x03,0xE8,
    0x10,0x14,0x00,0x3C,0x00,0x00,0x01,0x73,0x00,0x00,0x01,0x76,0xE9,0x2D,0x4F,0xF0,
    0xE2,0x4D,0xDE,0x17,0xEB,0x00,0xB9,0x92,0xE3,0xA0,0x10,0x00,0xE3,0xA0,0x20,0x03,
    0xE5,0x9F,0x0E,0x68,0xEB,0x00,0xB3,0x20,
};

int _main()
{
    int level = disable_interrupts();
    uint32_t control_register = disable_mmu();

    // patch kernel thread stack check
    *(volatile uint32_t*) 0x0812c138 = 0xe3a00000; // mov r0, #0
    *(volatile uint32_t*) 0x0812c13c = 0xe12fff1e; // bx lr

    // load arm_user
    memcpy((void*) 0x101312d0, arm_user, arm_user_size);

    // restore overwritten memory
    memcpy((void*) 0x081298bc, repairData_set_fault_behavior, sizeof(repairData_set_fault_behavior));
    memcpy((void*) 0x081296e4, repairData_set_panic_behavior, sizeof(repairData_set_panic_behavior));
    memcpy((void*) 0x10100174, repairData_usb_root_thread, sizeof(repairData_usb_root_thread));

    // map the entire free kernel memory
    ios_map_shared_info_t map_info;
    map_info.paddr = 0x08135000;
    map_info.vaddr = 0x08135000;
    map_info.size = 0xb000;
    map_info.domain = 0; // KERNEL
    map_info.type = 3;
    map_info.cached = 0xffffffff;
    _iosMapSharedUserExecution(&map_info);

    // reenable mmu
    restore_mmu(control_register);

    // invalidate all cache
    invalidate_dcache(NULL, 0x4001);
    invalidate_icache();

    // restore interrupts
    enable_interrupts(level);

    // give IOS-USB full access to FS
    setClientCapabilities(4, 0xb, 0xffffffffffffffffllu);

    // load recovery from SD
    if (load_recovery() < 0) {
       // power off on fail
       IOS_Shutdown(0);
    }

    return 0;
}
